use std::{cmp::Ordering, fmt::{Display, Formatter}};

use rotom_data::shared::subscription_models::{ExchangeId, Instrument};
use serde::{Deserialize, Serialize};


use crate::portfolio::position::Side;

use super::ClientOrderId;

/// Type of [`Order`].
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub enum OrderKind {
    Market,
    Limit,
    PostOnly,
    ImmediateOrCancel,
}

impl Display for OrderKind {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                OrderKind::Market => "market",
                OrderKind::Limit => "limit",
                OrderKind::PostOnly => "post_only",
                OrderKind::ImmediateOrCancel => "immediate_or_cancel",
            }
        )
    }
}

/// Todo:
#[derive(Clone, Eq, PartialEq, PartialOrd, Debug, Deserialize, Serialize)]
pub struct Order<State> {
    pub exchange: ExchangeId,
    pub instrument: Instrument,
    pub cid: ClientOrderId,
    pub side: Side,
    pub state: State,
}

/// The initial state of an [`Order`]. Sent to the [`ExecutionClient`](crate::ExecutionClient) for
/// actioning.
#[derive(Copy, Clone, PartialEq, PartialOrd, Debug, Deserialize, Serialize)]
pub struct RequestOpen {
    pub kind: OrderKind,
    pub price: f64,
    pub quantity: f64,
}

impl Order<RequestOpen> {
    pub fn required_available_balance(&self) -> (&String, f64) {
        match self.side {
            Side::Buy => (
                &self.instrument.quote,
                self.state.price * self.state.quantity,
            ),
            Side::Sell => (&self.instrument.base, self.state.quantity),
        }
    }
}

/// State of an [`Order`] after a [`RequestOpen`] has been sent to the
/// [`ExecutionClient`](crate::ExecutionClient), but a confirmation response has not been received.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct InFlight;

/// State of an [`Order`] after a request has been made for it to be [`Cancelled`].
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct RequestCancel {
    pub id: OrderId,
}

impl<Id> From<Id> for RequestCancel
where
    Id: Into<OrderId>,
{
    fn from(id: Id) -> Self {
        Self { id: id.into() }
    }
}

/// Todo:
#[derive(Clone, PartialEq, Debug, Deserialize, Serialize)]
pub struct Open {
    pub id: OrderId,
    pub price: f64,
    pub quantity: f64,
    pub filled_quantity: f64,
}

impl Open {
    pub fn remaining_quantity(&self) -> f64 {
        self.quantity - self.filled_quantity
    }
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Deserialize, Serialize)]
pub enum OrderFill {
    Full,
    Partial,
}

impl Ord for Order<Open> {
    fn cmp(&self, other: &Self) -> Ordering {
        self.partial_cmp(other)
            .unwrap_or_else(|| panic!("{:?}.partial_cmp({:?}) impossible", self, other))
    }
}

impl PartialOrd for Order<Open> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        match (self.side, other.side) {
            (Side::Buy, Side::Buy) => match self.state.price.partial_cmp(&other.state.price)? {
                Ordering::Equal => self
                    .state
                    .remaining_quantity()
                    .partial_cmp(&other.state.remaining_quantity()),
                non_equal => Some(non_equal),
            },
            (Side::Sell, Side::Sell) => match other.state.price.partial_cmp(&self.state.price)? {
                Ordering::Equal => other
                    .state
                    .remaining_quantity()
                    .partial_cmp(&self.state.remaining_quantity()),
                non_equal => Some(non_equal),
            },
            _ => None,
        }
    }
}

impl Eq for Order<Open> {}

/// State of an [`Order`] after being [`Cancelled`].
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct Cancelled {
    pub id: OrderId,
}

impl<Id> From<Id> for Cancelled
where
    Id: Into<OrderId>,
{
    fn from(id: Id) -> Self {
        Self { id: id.into() }
    }
}

/// [`Order`] identifier generated by an exchange. Cannot assume this is unique across each
/// [`Exchange`](barter_integration::model::Exchange),
/// [`Market`](barter_integration::model::Market), or
/// [`Instrument`](barter_integration::model::Instrument).
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct OrderId(pub String);

impl<S> From<S> for OrderId
where
    S: Display,
{
    fn from(id: S) -> Self {
        Self(id.to_string())
    }
}

impl From<&Order<RequestOpen>> for Order<InFlight> {
    fn from(request: &Order<RequestOpen>) -> Self {
        Self {
            exchange: request.exchange.clone(),
            instrument: request.instrument.clone(),
            cid: request.cid,
            side: request.side,
            state: InFlight,
        }
    }
}

impl From<(OrderId, Order<RequestOpen>)> for Order<Open> {
    fn from((id, request): (OrderId, Order<RequestOpen>)) -> Self {
        Self {
            exchange: request.exchange.clone(),
            instrument: request.instrument.clone(),
            cid: request.cid,
            side: request.side,
            state: Open {
                id,
                price: request.state.price,
                quantity: request.state.quantity,
                filled_quantity: 0.0,
            },
        }
    }
}

impl From<Order<Open>> for Order<Cancelled> {
    fn from(order: Order<Open>) -> Self {
        Self {
            exchange: order.exchange.clone(),
            instrument: order.instrument.clone(),
            cid: order.cid,
            side: order.side,
            state: Cancelled { id: order.state.id },
        }
    }
}